create table "public"."answers" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "team" uuid not null,
    "submitted_by" uuid not null default auth.uid(),
    "text" text not null,
    "task" bigint not null,
    "grade" integer,
    "grade_comment" text
);


alter table "public"."answers" enable row level security;

create table "public"."competitions" (
    "id" uuid not null,
    "created_at" timestamp with time zone default now(),
    "start_date" timestamp with time zone not null,
    "end_date" timestamp with time zone not null,
    "name" character varying not null
);


alter table "public"."competitions" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "fullName" text not null,
    "username" text not null,
    "team" uuid,
    "isBuddy" boolean not null default false
);


alter table "public"."profiles" enable row level security;

create table "public"."tasks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone default now(),
    "competition" uuid not null,
    "title" character varying not null,
    "description" text not null,
    "points" integer not null,
    "category" character varying not null default 'Gay Sex'::character varying,
    "difficulty" smallint not null default '5'::smallint
);


alter table "public"."tasks" enable row level security;

create table "public"."teams" (
    "id" uuid not null,
    "created_at" timestamp with time zone default now(),
    "name" text not null,
    "created_by" uuid not null
);


alter table "public"."teams" enable row level security;

CREATE UNIQUE INDEX answers_pkey ON public.answers USING btree (id);

CREATE UNIQUE INDEX competitions_pkey ON public.competitions USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX tasks_pkey ON public.tasks USING btree (id);

CREATE UNIQUE INDEX team_pkey ON public.teams USING btree (id);

alter table "public"."answers" add constraint "answers_pkey" PRIMARY KEY using index "answers_pkey";

alter table "public"."competitions" add constraint "competitions_pkey" PRIMARY KEY using index "competitions_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."tasks" add constraint "tasks_pkey" PRIMARY KEY using index "tasks_pkey";

alter table "public"."teams" add constraint "team_pkey" PRIMARY KEY using index "team_pkey";

alter table "public"."answers" add constraint "answers_submitted_by_fkey" FOREIGN KEY (submitted_by) REFERENCES profiles(id) not valid;

alter table "public"."answers" validate constraint "answers_submitted_by_fkey";

alter table "public"."answers" add constraint "answers_task_fkey" FOREIGN KEY (task) REFERENCES tasks(id) not valid;

alter table "public"."answers" validate constraint "answers_task_fkey";

alter table "public"."answers" add constraint "answers_team_fkey" FOREIGN KEY (team) REFERENCES teams(id) not valid;

alter table "public"."answers" validate constraint "answers_team_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_team_fkey" FOREIGN KEY (team) REFERENCES teams(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_team_fkey";

alter table "public"."tasks" add constraint "tasks_competition_fkey" FOREIGN KEY (competition) REFERENCES competitions(id) ON DELETE CASCADE not valid;

alter table "public"."tasks" validate constraint "tasks_competition_fkey";

alter table "public"."teams" add constraint "teams_created_by_fkey" FOREIGN KEY (created_by) REFERENCES profiles(id) not valid;

alter table "public"."teams" validate constraint "teams_created_by_fkey";

create policy "Buddies can update answers"
on "public"."answers"
as permissive
for update
to authenticated
using (true)
with check ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles."isBuddy" = true))));


create policy "Team members & buddies can select answers"
on "public"."answers"
as permissive
for select
to authenticated
using ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE ((profiles."isBuddy" = true) OR (profiles.team = profiles.id)))));


create policy "Team members can insert answers if no answer exists"
on "public"."answers"
as permissive
for insert
to authenticated
with check ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (answers.team = profiles.team))));


create policy "Buddy can do everything"
on "public"."competitions"
as permissive
for all
to authenticated
with check ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles."isBuddy" = true))));


create policy "Everyone authenticated can read"
on "public"."competitions"
as permissive
for select
to authenticated
using (true);


create policy "Public profiles are viewable by everyone."
on "public"."profiles"
as permissive
for select
to public
using (true);


create policy "Users can insert their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update own profile."
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Authenticated can read"
on "public"."tasks"
as permissive
for select
to authenticated
using (true);


create policy "Buddy can do everything"
on "public"."tasks"
as permissive
for all
to authenticated
using (true)
with check ((auth.uid() IN ( SELECT profiles.id
   FROM profiles
  WHERE (profiles."isBuddy" = true))));


create policy "Anyone can create a team"
on "public"."teams"
as permissive
for insert
to authenticated
with check (true);


create policy "Get all teams & members if authenticated"
on "public"."teams"
as permissive
for select
to authenticated
using (true);



